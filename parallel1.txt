#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

#define MIN_ARRAY_SIZE 100000
#define NUM_THREAD_CONFIGS 3
#define DISPLAY_RUNS 5

/* Kernel for array summation on GPU */
__global__ void compute_sum_gpu(float* data, float* result, int elements) {
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < elements) {
        atomicAdd(result, data[idx]);
    }
}

/* Initialize array with random values */
void initialize_data(float* data, int elements) {
    for (int i = 0; i < elements; i++) {
        data[i] = rand() / (float)RAND_MAX;
    }
}

/* Get integer input from user */
int get_positive_input(const char* prompt, int min_value) {
    int value;
    printf("%s", prompt);
    if (scanf("%d", &value) != 1 || value < min_value) {
        fprintf(stderr, "Error: value must be at least %d!\n", min_value);
        exit(EXIT_FAILURE);
    }
    return value;
}

int main() {
    // Get parameters from user
    const int array_size = get_positive_input(
        "Enter array size (minimum 100000 elements): ", 
        MIN_ARRAY_SIZE
    );
    const int experiment_count = get_positive_input(
        "Enter number of experiments: ", 
        1
    );

    // Allocate and initialize data on CPU
    float* host_data = (float*)malloc(array_size * sizeof(float));
    float host_sum = 0.0f;
    initialize_data(host_data, array_size);

    // Allocate memory on GPU
    float* device_data = NULL;
    float* device_sum = NULL;
    cudaMalloc((void**)&device_data, array_size * sizeof(float));
    cudaMalloc((void**)&device_sum, sizeof(float));

    // Copy data to GPU
    cudaMemcpy(device_data, host_data, array_size * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemset(device_sum, 0, sizeof(float));

    // Test different thread configurations
    const int thread_configs[NUM_THREAD_CONFIGS] = {4, 8, 16};
    double* execution_times = (double*)malloc(experiment_count * sizeof(double));

    for (int config = 0; config < NUM_THREAD_CONFIGS; config++) {
        const int threads = thread_configs[config];
        const int blocks = (array_size + threads - 1) / threads;

        cudaEvent_t timer_start, timer_end;
        cudaEventCreate(&timer_start);
        cudaEventCreate(&timer_end);

        double total_execution_time = 0;

        printf("\nConfiguration: %d threads per block\n", threads);
        printf("Array size: %d elements\n", array_size);

        for (int run = 0; run < experiment_count; run++) {
            cudaMemset(device_sum, 0, sizeof(float));

            cudaEventRecord(timer_start);
            compute_sum_gpu<<<blocks, threads>>>(device_data, device_sum, array_size);
            cudaEventRecord(timer_end);
            cudaEventSynchronize(timer_end);

            float elapsed_ms = 0;
            cudaEventElapsedTime(&elapsed_ms, timer_start, timer_end);
            execution_times[run] = elapsed_ms / 1000.0;
            total_execution_time += execution_times[run];
        }

        // Get result from GPU
        cudaMemcpy(&host_sum, device_sum, sizeof(float), cudaMemcpyDeviceToHost);
        printf("Element sum: %.2f\n", host_sum);

        // Display results
        const int display_count = (experiment_count < DISPLAY_RUNS) ? experiment_count : DISPLAY_RUNS;
        
        printf("\nFirst %d executions:\n", display_count);
        for (int i = 0; i < display_count; i++) {
            printf("Execution %4d: %.6f sec\n", i + 1, execution_times[i]);
        }

        if (experiment_count > DISPLAY_RUNS) {
            printf("\nLast %d executions:\n", display_count);
            for (int i = experiment_count - display_count; i < experiment_count; i++) {
                printf("Execution %4d: %.6f sec\n", i + 1, execution_times[i]);
            }
        }

        printf("\nAverage time: %.6f sec\n", total_execution_time / experiment_count);
        
        cudaEventDestroy(timer_start);
        cudaEventDestroy(timer_end);
    }

    // Free resources
    free(execution_times);
    cudaFree(device_data);
    cudaFree(device_sum);
    free(host_data);

    return EXIT_SUCCESS;
}
